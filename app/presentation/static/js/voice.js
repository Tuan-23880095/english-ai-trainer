// /static/js/voice.js
import { startRecording, resetSessionTimeout, stopSessionTimeout } from "/static/js/recorder.js";

function getAuthHeaders() {
    const email = sessionStorage.getItem("email");
    const password = sessionStorage.getItem("password");
    return { "x-email": email, "x-password": password };
}

const btn = document.getElementById("start");
const stat = document.getElementById("status");
const conv = document.getElementById("conversation");

let first = true;
let sessionActive = false;
let sessionId = null;

// H√†m l·∫•y headers cho m·ªçi fetch h·ªôi tho·∫°i, lu√¥n c√≥ session_id
function getVoiceHeaders(isJson = false) {
    const headers = {
        ...getAuthHeaders(),
        "x-session-id": sessionId
    };
    if (isJson) headers["Content-Type"] = "application/json";
    return headers;
}

function speakText(text) {
    return new Promise(resolve => {
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = "en-US";
        utter.onend = resolve;
        speechSynthesis.speak(utter);
    });
}

function endSession() {
    sessionActive = false;
    stopSessionTimeout();
    stat.textContent = "üí§ K·∫øt th√∫c h·ªôi tho·∫°i (user im l·∫∑ng >30s)";
}
async function fetchKeywords(conversation) {
    const res = await fetch("/api/keywords", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ conversation })
    });
    const data = await res.json();
    return data.keywords || [];
}
async function updateKeywords() {
    // L·∫•y to√†n b·ªô h·ªôi tho·∫°i d∆∞·ªõi d·∫°ng text
    let text = [...document.querySelectorAll("#conversation p")]
        .map(p => p.textContent)
        .join("\n")
        .trim();

    // N·∫øu ch∆∞a c√≥ h·ªôi tho·∫°i, kh√¥ng g·ªçi API
    if (!text) {
        document.getElementById('keywords').innerHTML = "<em>Ch∆∞a c√≥ h·ªôi tho·∫°i ƒë·ªÉ tr√≠ch xu·∫•t t·ª´ v·ª±ng.</em>";
        return;
    }

    // G·ªçi API l·∫•y t·ª´ kh√≥a
    const keywords = await fetchKeywords(text);

    // T·∫°o HTML hi·ªÉn th·ªã t·ª´ v·ª±ng
    let html = '';
    if (keywords.length === 0) {
        html = "<em>Kh√¥ng t√¨m th·∫•y t·ª´ v·ª±ng n·ªïi b·∫≠t trong h·ªôi tho·∫°i n√†y.</em>";
    } else {
        for (const k of keywords) {
            html += `
                <div class="vocab-word">
                    <b>${k.word}</b> <i>/${k.ipa}/</i><br>
                    <span>${k.meaning}</span><br>
                    <audio src="${k.voice}" controls></audio><br>
                    <em>V√≠ d·ª•:</em> ${k.example}
                    <hr>
                </div>
            `;
        }
    }
    document.getElementById('keywords').innerHTML = html;
}

async function ai_conversation_loop() {
    if (!sessionActive) return;
    if (first) {
        stat.textContent = "ƒêang h·ªèi AI kh·ªüi ƒë·ªông...";
        try {
            const res = await fetch("/api/voice", {
                method: "POST",
                headers: getVoiceHeaders(true), // truy·ªÅn session_id + Content-Type
                body: JSON.stringify({ prompt: "You are a friendly English tutor (you can use Vietnamese if needed) and you start the conversation. Please always answer concisely and shortly, no more than 2 sentences." })
            });
            if (!res.ok) throw new Error(await res.text());
            const data = await res.json();
            conv.innerHTML += `<p class="ai"><b>AI:</b> ${data.answer}</p>`;
            // L·∫•y l·∫°i session_id t·ª´ response n·∫øu backend sinh m·ªõi (optional)
            if (data.session_id) sessionId = data.session_id;
            await speakText(data.answer);
            first = false;
            resetSessionTimeout(endSession);
            await ai_conversation_loop();
        } catch (err) {
            stat.textContent = "‚ùå " + err.message;
            sessionActive = false;
        }
        return;
    }
    stat.textContent = "üé§ ƒêang nghe...";
    resetSessionTimeout(endSession);
    const blob = await startRecording();
    if (!sessionActive) return;
    stat.textContent = "‚è≥ ƒêang x·ª≠ l√Ω...";
    resetSessionTimeout(endSession);
    const fd = new FormData();
    fd.append("file", blob, "audio.webm");
    try {
        const res = await fetch("/api/voice", {
            method: "POST",
            body: fd,
            headers: getVoiceHeaders() // ch·ªâ truy·ªÅn session_id, kh√¥ng c·∫ßn Content-Type
        });
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        conv.innerHTML += `<p class="user"><b>You:</b> ${data.user}</p>`;
        conv.innerHTML += `<p class="ai"><b>AI:</b> ${data.answer}</p>`;
        if (data.session_id) sessionId = data.session_id; // lu√¥n c·∫≠p nh·∫≠t l·∫°i n·∫øu backend tr·∫£ v·ªÅ
        await speakText(data.answer);
        if (sessionActive) {
            resetSessionTimeout(endSession);
            await ai_conversation_loop();
        }
        stat.textContent = "";
    } catch (err) {
        stat.textContent = "‚ùå " + err.message;
        sessionActive = false;
    }
}

btn.onclick = () => {
    if (!sessionActive) {
        // Sinh sessionId m·ªõi khi b·∫Øt ƒë·∫ßu h·ªôi tho·∫°i m·ªõi
        sessionId = (crypto.randomUUID ? crypto.randomUUID() : Date.now().toString());
        first = true;
        sessionActive = true;
        ai_conversation_loop();
    }
};
