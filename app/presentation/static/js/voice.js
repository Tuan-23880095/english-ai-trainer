// /static/js/voice.js
let isSpeaking = false; // ƒê√°nh d·∫•u tr·∫°ng th√°i AI ƒëang n√≥i
function speakText(text) {
    return new Promise(resolve => {
        if (speechSynthesis.speaking) speechSynthesis.cancel();
        let utter = new SpeechSynthesisUtterance(text);
        utter.lang = "en-US";
        isSpeaking = true;
        // Disable n√∫t "B·∫Øt ƒë·∫ßu th·ª±c h√†nh n√≥i"
        document.getElementById("start").disabled = true;
        utter.onend = () => {
            isSpeaking = false;
            document.getElementById("start").disabled = false;
            resolve();
        };
        speechSynthesis.speak(utter);
    });
}

import { startRecording, resetSessionTimeout, stopSessionTimeout } from "/static/js/recorder.js";

function getAuthHeaders() {
    const email = sessionStorage.getItem("email");
    const password = sessionStorage.getItem("password");
    return { "x-email": email, "x-password": password };
}

const btn = document.getElementById("start");
const stat = document.getElementById("status");
const conv = document.getElementById("conversation");

let first = true;
let sessionActive = false;
let sessionId = null;

// H√†m l·∫•y headers cho m·ªçi fetch h·ªôi tho·∫°i, lu√¥n c√≥ session_id
function getVoiceHeaders(isJson = false) {
    const headers = {
        ...getAuthHeaders(),
        "x-session-id": sessionId
    };
    if (isJson) headers["Content-Type"] = "application/json";
    return headers;
}

function speakText(text) {
    return new Promise(resolve => {
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = "en-US";
        utter.onend = resolve;
        speechSynthesis.speak(utter);
    });
}

function endSession() {
    sessionActive = false;
    stopSessionTimeout();
    stat.textContent = "üí§ K·∫øt th√∫c h·ªôi tho·∫°i (user im l·∫∑ng >30s)";
}
async function fetchKeywords(conversation) {
    const res = await fetch("/api/keywords", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ conversation })
    });
    const data = await res.json();
    return data.keywords || [];
}
async function updateKeywords() {
    let text = [...document.querySelectorAll("#conversation p")]
        .map(p => p.textContent)
        .join("\n")
        .trim();

    if (!text) {
        document.getElementById('keywords').innerHTML = "<em>Ch∆∞a c√≥ h·ªôi tho·∫°i ƒë·ªÉ tr√≠ch xu·∫•t t·ª´ v·ª±ng.</em>";
        return;
    }

    const keywords = await fetchKeywords(text);

    let html = '';
    if (keywords.length === 0) {
        html = "<em>Kh√¥ng t√¨m th·∫•y t·ª´ v·ª±ng n·ªïi b·∫≠t trong h·ªôi tho·∫°i n√†y.</em>";
    } else {
        for (const k of keywords) {
            html += `
                <div class="vocab-word" title="Nh·∫•n v√†o ƒë·ªÉ l∆∞u t·ª´ n√†y">
                    <div style="display:flex; align-items:center; gap:0.6em;">
                        <b>${k.word}</b>
                        <i>/${k.ipa}/</i>
                        <button class="save-word-btn" data-word="${k.word}" title="L∆∞u t·ª´ v·ª±ng">
                            <span style="color:#0066cc;">‚òÜ</span>
                        </button>
                        <button class="play-word-btn" data-voice="${k.voice}" title="Nghe ph√°t √¢m">
                            <span style="color:#4b2;">üîä</span>
                        </button>
                    </div>
                    <span class="meaning" style="color:#29743c;font-weight:500;" title="Nghƒ©a ti·∫øng Vi·ªát">${k.meaning}</span><br>
                    <em>V√≠ d·ª•:</em> <span title="C√¢u v√≠ d·ª•">${k.example}</span>
                    <hr>
                </div>
            `;
        }
    }
    document.getElementById('keywords').innerHTML = html;

    // G√°n s·ª± ki·ªán cho n√∫t "L∆∞u t·ª´" v√† "Ph√°t √¢m" sau khi render html
    document.querySelectorAll('.save-word-btn').forEach(btn => {
        btn.onclick = function() {
            alert("ƒê√£ l∆∞u t·ª´: " + btn.dataset.word);
            // ...ho·∫∑c x·ª≠ l√Ω l∆∞u th·ª±c t·∫ø v√†o localStorage/database...
        }
    });
    document.querySelectorAll('.play-word-btn').forEach(btn => {
        btn.onclick = function() {
            let audio = new Audio(btn.dataset.voice);
            audio.play();
        }
    });
}

async function ai_conversation_loop() {
    if (!sessionActive) return;
    if (first) {
        stat.textContent = "ƒêang h·ªèi AI kh·ªüi ƒë·ªông...";
        try {
            const res = await fetch("/api/voice", {
                method: "POST",
                headers: getVoiceHeaders(true), // truy·ªÅn session_id + Content-Type
                body: JSON.stringify({ prompt: "You are a friendly English tutor (you can use Vietnamese if needed) and you start the conversation. Please always answer concisely and shortly, no more than 2 sentences." })
            });
            if (!res.ok) throw new Error(await res.text());
            const data = await res.json();
            conv.innerHTML += `<p class="ai"><b>AI:</b> ${data.answer}</p>`;
            // L·∫•y l·∫°i session_id t·ª´ response n·∫øu backend sinh m·ªõi (optional)
            if (data.session_id) sessionId = data.session_id;
            await speakText(data.answer);
            first = false;
            resetSessionTimeout(endSession);
            await ai_conversation_loop();
        } catch (err) {
            stat.textContent = "‚ùå " + err.message;
            sessionActive = false;
        }
        return;
    }
    stat.textContent = "üé§ ƒêang nghe...";
    resetSessionTimeout(endSession);
    const blob = await startRecording();
    if (!sessionActive) return;
    stat.textContent = "‚è≥ ƒêang x·ª≠ l√Ω...";
    resetSessionTimeout(endSession);
    const fd = new FormData();
    fd.append("file", blob, "audio.webm");
    try {
        const res = await fetch("/api/voice", {
            method: "POST",
            body: fd,
            headers: getVoiceHeaders() // ch·ªâ truy·ªÅn session_id, kh√¥ng c·∫ßn Content-Type
        });
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        conv.innerHTML += `<p class="user"><b>You:</b> ${data.user}</p>`;
        conv.innerHTML += `<p class="ai"><b>AI:</b> ${data.answer}</p>`;
        if (data.session_id) sessionId = data.session_id; // lu√¥n c·∫≠p nh·∫≠t l·∫°i n·∫øu backend tr·∫£ v·ªÅ
        await speakText(data.answer);
        if (sessionActive) {
            resetSessionTimeout(endSession);
            await ai_conversation_loop();
        }
        stat.textContent = "";
    } catch (err) {
        stat.textContent = "‚ùå " + err.message;
        sessionActive = false;
    }
}

btn.onclick = () => {
    if (!sessionActive) {
        // Sinh sessionId m·ªõi khi b·∫Øt ƒë·∫ßu h·ªôi tho·∫°i m·ªõi
        sessionId = (crypto.randomUUID ? crypto.randomUUID() : Date.now().toString());
        first = true;
        sessionActive = true;
        ai_conversation_loop();
    }
};
